package {{.Package}}

import (
	"crypto/rand"
	"encoding/hex"
	"flag"
	{{- if index .Params "rotate" }}
	"time"
	{{ end -}}
	{{- if index .Params "types" }}
	"{{ index .Params "module" }}"
	{{ end -}}

	{{- range index .Params "applications" }}
	"{{- index $.Params "module" }}/apps/{{ .LoName }}"
	{{ end }}

	{{ range index .Params "ext_applications" }}
	"{{- index .Params "import" }}"
	{{- end }}
	{{ range index .Params "loggers" }}
	"{{- index .Params "import" }}"
	{{- end }}

	"ergo.services/ergo"
	"ergo.services/ergo/gen"
	{{- if or (index .Params "tls") (index .Params "rotate") }}
	"ergo.services/ergo/lib"
	{{ end }}

)

var (
	OptionNodeName   string
	OptionNodeCookie string
	{{ if index .Params "cloud" }}
	OptionCloudClusterName   string
	OptionCloudClusterCookie string
	{{ end }}
)

func init() {
	// generate random value for cookie
	buff := make([]byte, 12)
	rand.Read(buff)
	randomCookie := hex.EncodeToString(buff)

	{{ if index .Params "host" -}}
	flag.StringVar(&OptionNodeName, "name", "{{ .Name }}@{{ index .Params "host" }}", "node name")
	{{ else -}}
	flag.StringVar(&OptionNodeName, "name", "{{ .Name }}@localhost", "node name")
	{{ end -}}
	flag.StringVar(&OptionNodeCookie, "cookie", randomCookie, "a secret cookie for the network messaging")
	{{ if index .Params "cloud" }}
	// cloud options
	flag.StringVar(&OptionCloudClusterName, "cloud-cluster", "{{ index .Params "cloud" }}", "cloud cluster name")
	flag.StringVar(&OptionCloudClusterCookie, "cloud-cookie", "", "cloud cluster cookie")
	{{ end }}
}

func main() {
	var options gen.NodeOptions

	flag.Parse()
	{{ if index .Params "cloud" }}
	cloudOptions := cloud.Options{
		Cluster: OptionCloudClusterName,
		Cookie: OptionCloudClusterCookie,
	}
	{{ end -}}

	{{ if index .Params "applications" }}
	// create applications that must be started
	apps := []gen.ApplicationBehavior{ {{ range index .Params "ext_applications" }}
	{{ .LoName }}.Create{{ .Name }}({{ index .Params "args" }}), {{ end -}}
	{{ range index .Params "applications" }}
	{{ .LoName }}.Create{{ .Name }}(), {{ end }}
	}
	options.Applications = apps
	{{ end }}

	{{ if index .Params "tls" }}
	// enable TLS with self-signed certificate
	cert, _ := lib.GenerateSelfSignedCert("{{ .Name }} service")
	options.Network.CertManager = gen.CreateCertManager(cert)
	{{ end }}
	{{ if index .Params "rotate" }}
	// add log rotation for the default logger.
	// it makes disabled logging to the os.Stdout
	rotate := lib.RotateOptions{
		Period: time.Minute * 5,
		Compress: false, // to enable gziping
		Depth: 12, // keep logs for the last 2 hours
		Prefix: OptionNodeName, // filename format: <Path>/<Prefix>.YYYYMMDDHHMi.log[.gz]
	}
	output, err := lib.CreateRotateWriter(rotate)
	if err != nil {
		panic(err)
	}
	defer output.Close()
	options.Log.DefaultLogger.Output = output
	{{ end -}}

	{{ if index .Params "loggers" }}
	{{ if not (index .Params "rotate") }}
	// disable default logger to get rid of multiple logging to the os.Stdout
	options.Log.DefaultLogger.Disable = true
	{{ end }}
	{{ range index .Params "loggers" }}
	// add logger "{{ .Name }}".
	// it enables colorized logging to the os.Stdout
	logger{{ .Name }} := gen.Logger{
		Name: "{{ .Name }}",
		Logger: {{ .Name }}.CreateLogger({{ .Name }}.Options{}),
	}
	options.Log.Loggers = append(options.Log.Loggers, logger{{ .Name }})
	{{ end }}
	{{ end }}
	options.Network.Cookie = OptionNodeCookie

	// starting node
	node, err := ergo.StartNode(gen.Atom(OptionNodeName), options)
	if err != nil {
		panic(err)
	}

	{{ if index .Params "types" }}
	// register network messages
	if err := node.Network().RegisterMessage({{ index $.Params "module-name" }}.Messages...); err != nil {
		panic(err)
	}
	{{ end }}

	{{ range .Children}}
	// starting process {{ .Name }}
	if _, err := node.SpawnRegister("{{ .LoName }}", factory_{{ .Name }}, gen.ProcessOptions{}); err != nil {
		panic(err)
	}
	{{ end }}

	node.Wait()
}

